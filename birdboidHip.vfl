// シミュレーション VEX（Points, every frame）
// ========= パラメータ =========
// 近傍半径（ドーナツ型の内外）
float r_min_c = ch("r_min_c");  // Cohesion 内側
float r_max_c = ch("r_max_c");  // Cohesion 外側
float r_min_s = ch("r_min_s");  // Separation 内側
float r_max_s = ch("r_max_s");  // Separation 外側
float r_min_a = ch("r_min_a");  // Alignment 内側
float r_max_a = ch("r_max_a");  // Alignment 外側

// 係数
float k1 = ch("k1");  // 結合係数
float k2 = ch("k2");  // 分離係数
float k3 = ch("k3");  // 整列係数
float v  = ch("speed"); // 進行速度（ステップ幅）
float e  = ch("repulsion"); // 壁反発係数

// フィールドサイズと視野角
float width = ch("width");
float fov   = ch("fov"); // ラジアン（例：pi/3）

// ========= ユーティリティ関数 ==========

// 点 p の rmin〜rmax にいる近傍の point 配列を得る
int[] in_range_points(int p; float rmin; float rmax)
{
    vector Pself = point(0, "P", p);
    int pts[] = nearpoints(0, Pself, rmax);
    int res[] = {};
    foreach (int q; pts)
    {
        if (q==p) continue;
        float d = distance(Pself, point(0,"P",q));
        if (d > rmin && d < rmax)
            append(res, q);
    }
    return res;
}

// Cohesion/Separation 用：重心（なければ擬似ノイズ付きの自身座標）
vector get_cg(int p; float rmin; float rmax)
{
    int nbrs[] = in_range_points(p, rmin, rmax);
    if (len(nbrs)==0)
    {
        vector P = point(0,"P",p);
        // ごく小さいランダム揺らぎ
        float j = 0.0002;
        vector n = set(rand(set(p,1))-0.5, rand(set(p,2))-0.5, 0)*2*j;
        return P + n;
    }
    vector sum = {0,0,0};
    foreach (int q; nbrs) sum += point(0,"P",q);
    return sum / float(len(nbrs));
}

// Alignment 用：視野角内の近傍の平均速度ベクトル
vector get_alignment(int p; float rmin; float rmax; float fov)
{
    int nbrs[] = in_range_points(p, rmin, rmax);
    if (len(nbrs)==0) return {0,0,0};

    vector Pself = point(0,"P",p);
    vector Vself = normalize(point(0,"vel",p));

    vector acc = {0,0,0};
    int cnt = 0;

    foreach (int q; nbrs)
    {
        vector Pq = point(0,"P",q);
        vector dir_to_q = normalize(Pq - Pself);

        // 視野角：acos(dot)) < fov で判定
        float ang = acos(clamp(dot(Vself, dir_to_q), -1.0, 1.0));
        if (ang < fov)
        {
            acc += point(0,"vel",q);
            cnt++;
        }
    }
    if (cnt==0) return {0,0,0};
    vector avg = acc / float(cnt);
    return avg;
}

// 壁反発：フィールドは [0,width]×[0,width] の箱を想定
vector get_repulsion(int p; float width)
{
    vector P = point(0,"P",p);
    float left  = P.x - 0.0;
    float right = width - P.x;
    float under = P.y - 0.0;
    float upper = width - P.y;

    vector vL = {0,0,0}, vR = {0,0,0}, vU = {0,0,0}, vD = {0,0,0};

    if (left  < 1.0) vL = set( 1, 0, 0) / max(left*left, 1e-4);
    if (right < 1.0) vR = set(-1, 0, 0) / max(right*right,1e-4);
    if (under < 1.0) vD = set( 0, 1, 0) / max(under*under,1e-4);
    if (upper < 1.0) vU = set( 0,-1, 0) / max(upper*upper,1e-4);

    return vL + vR + vD + vU;
}

// ========= メイン（1ポイントごと） =========

vector P  = @P;
vector V  = v@vel;
if (length(V) < 1e-6) V = set(1,0,0);

// 3ルールの目標ベクトル
vector cohesion   = get_cg(@ptnum, r_min_c, r_max_c) - P;
vector separation = get_cg(@ptnum, r_min_s, r_max_s) - P; // 元実装に合わせる（重心差で避ける）
vector alignment  = get_alignment(@ptnum, r_min_a, r_max_a, fov);
vector repul      = get_repulsion(@ptnum, width);

// 合成（元コードの符号＋係数）
vector vT = V + k1*cohesion - k2*separation + k3*alignment + e*repul;
if (length2(vT) > 1e-12) vT = normalize(vT);

// 位置と速度を更新（Solver が前フレーム保持）
@P     = P + vT * v;
v@vel  = vT;

// お好みで色づけ
@Cd = set(0.2, 0.5, 1.0);
